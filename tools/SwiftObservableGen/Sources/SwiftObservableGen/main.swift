// The Swift Programming Language
// https://docs.swift.org/swift-book

import Foundation

struct Args {
    let manifestPath: String
    let outputDir: String
}

func parseArgs() throws -> Args {
    var manifest: String?
    var output: String?
    
    var it = CommandLine.arguments.dropFirst().makeIterator()
    while let arg = it.next() {
        switch arg {
        case "--manifest":
            manifest = it.next()
        case "--output":
            output = it.next()
        case "--help", "-h":
            throw NSError(domain: "help", code: 0)
        default:
            throw NSError(
                domain: "SwiftObservableGen",
                code: 2,
                userInfo: [
                    NSLocalizedDescriptionKey: "Unknown argument: \(arg)"
                ]
            )
        }
    }
    
    guard let manifest, !manifest.isEmpty else {
        throw NSError(
            domain: "SwiftObservableGen",
            code: 3,
            userInfo: [
                NSLocalizedDescriptionKey: "Missing --manifest <path>"
            ]
        )
    }
    guard let output, !output.isEmpty else {
        throw NSError(
            domain: "SwiftObservableGen",
            code: 4,
            userInfo: [
                NSLocalizedDescriptionKey: "Missing --output <dir>"
            ]
        )
    }
    
    return Args(manifestPath: manifest, outputDir: output)
}

func printUsage() {
    let exe = (CommandLine.arguments.first ?? "SwiftObservableGen")
    print(
        """
        Usage:
          \(exe) --manifest <path/to/swiftvm-manifest.json> --output <output/dir>
        
        Writes generated *.swift files into the output directory.
        """
    )
}

func writeFile(path: String, contents: String) throws {
    let url = URL(fileURLWithPath: path)
    try contents.data(using: .utf8)!.write(to: url, options: .atomic)
}

func renderWrapper(vm: ViewModelEntry, moduleImport: String) -> String {
    let wrapperName = "Observable\(vm.simpleName)"

    // State
    let stateDecl: String
    let initState: String
    if let state = vm.state {
        stateDecl = "@Published public private(set) var \(state.property): \(state.typeSimpleName)"
        initState = """
self.\(state.property) = vm.\(state.property).value
self._stateTask = Task { [weak self] in
    guard let self else { return }
    for await newValue in vm.\(state.property) {
        self.\(state.property) = newValue
    }
}
"""
    } else {
        stateDecl = "// No @Published state found in manifest.\n"
        initState = ""
    }
    
    // Actions
    let actions: String = vm.actions.map { action in
        let callParams = action.params.map { param in
            "\(param.paramLabel): \(param.paramLabel)"
        }
            .joined(separator: ", ")
        let funcParams = action.params.map { param in
            "\(param.paramLabel): \(param.typeSimpleName)"
        }
            .joined(separator: ", ")
        return """
public func \(action.function)(\(funcParams)) {
    vm.\(action.function)(\(callParams))
}
"""
    }
        .joined(separator: "\n\n")
    
    // If there are no actions, still generate something compilable
    let actionsBlock = actions.isEmpty
    ? "  // No actions declared in manifest.\n"
    : actions + "\n"

    var w = SwiftWriter()
    w.line("// Generated by SwiftObservableGen. DO NOT EDIT.")
    w.line()
    w.line("import Foundation")
    w.line("import Combine")
    w.line("import \(moduleImport)")
    w.line()
    w.line("@MainActor")
    w.line("public final class \(wrapperName): ObservableObject {")
    w.indent { w in
        w.line("private let vm: \(vm.simpleName)")
        w.line()
        w.block(stateDecl)
        w.line("private var _stateTask: Task<Void, Never>?")
        w.line()
        w.line("public init(_ vm: \(vm.simpleName)) {")
        w.indent { w in
            w.line("self.vm = vm")
            w.block(initState)
        }
        w.line("}")
        w.line()
        w.line("deinit {")
        w.indent { w in
            w.line("_stateTask?.cancel()")
            w.line("vm.dispose()")
        }
        w.line("}")
        w.line()
        w.block(actionsBlock)
    }
    w.line("}")
    w.line()
    return w.render()
}

func main() -> Int32 {
    do {
        let args = try parseArgs()
        let data = try Data(contentsOf: URL(fileURLWithPath: args.manifestPath))
        let manifest = try JSONDecoder().decode(Manifest.self, from: data)
        
        try FileManager.default.createDirectory(
            atPath: args.outputDir,
            withIntermediateDirectories: true
        )
        
        for vm in manifest.viewModels {
            let fileName = "\(vm.simpleName)+Observable.swift"
            let outPath = (args.outputDir as NSString).appendingPathComponent(
                fileName
            )
            let contents = renderWrapper(vm: vm, moduleImport: "SharedSDK")
            try writeFile(path: outPath, contents: contents)
        }
        
        print(
            "SwiftObservableGen: generated \(manifest.viewModels.count) file(s) into \(args.outputDir)"
        )
        return 0
    } catch let err as NSError where err.domain == "help" {
        printUsage()
        return 0
    } catch {
        fputs("SwiftObservableGen error: \(error)\n\n", stderr)
        printUsage()
        return 1
    }
}

exit(main())
